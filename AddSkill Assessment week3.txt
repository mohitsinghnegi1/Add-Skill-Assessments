Qus 1 :https://leetcode.com/problems/search-a-2d-matrix/

SOl:
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        #time complexity log n*m
        if(len(matrix)==0):
            return 0
        no_of_rows=len(matrix)
        
        
        no_of_cols=len(matrix[0])
        #t is total cells in the matrix
        total_elemnt=no_of_cols*no_of_rows
        
        l=0
        r=total_elemnt-1
        while(l<=r):
            
            #calculate a mid index
            mid=l+(r-l)/2
            
            #find the row of mid elemnt in a matrix
            rows=mid/no_of_cols
            #find the col of mid elemnt in a matrix
            col=mid%no_of_cols
            #now access the mid elemnt value
            mid_el=matrix[rows][col]
            
            if(mid_el==target):
                #if the elemnt val equals target then return true
                return True
            elif(mid_el<target):
                #if mid elemnt val less then target increament l
                l=mid+1
            else:
                r=mid-1
                #if mid elemnt val greater then target decrement r
        #if element not in matrix return False
        return False
            
Qus 2: https://leetcode.com/problems/spiral-matrix/
SOl:
class Solution(object):
    def spiralOrder(self, A):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if(A==[]):
            return []
        n=len(A)
        m=len(A[0])
        
        l=0
        r=m
        t=0
        b=n
        ans=[]
        while(l<r and t<b):
            for i in range(l,r):
                ans.append(A[t][i])
            t+=1
            for i in range(t,b):
                ans.append(A[i][r-1])
            r-=1
            if(t<b):
                for i in range(r-1,l-1,-1):
                    ans.append(A[b-1][i])
                b-=1
            if(l<r):
                for i in range(b-1,t-1,-1):
                    ans.append(A[i][l])
                l+=1
        return ans

        
#         l=0
#         r=m
#         t=0
#         b=n
       
        
#         ans=[]
#         while(l<r and t<b):
            
            
#             for i in range(l,r):
#                 ans.append(A[t][i])
#             t+=1
            
#             for i in range(t,b):
#                 ans.append(A[i][r-1])
#             r-=1
#             if(t<b):
#                 for i in range(r-1,l-1,-1):
#                     ans.append(A[b-1][i])
#                 b-=1
#             if(l<r):
#                 for i in range(b-1,t-1,-1):
#                     ans.append(A[i][l])
#                 l+=1
        
#         return ans
            
                
Qus3: https://leetcode.com/problems/find-the-difference/submissions/
Sol :
class Solution(object):
    def findTheDifference(self, s, t):

        #sol1
        # d={}
        # for i in s:
        #     d[i]=d.get(i,0)+1
        # d1={}
        # for j in t:
        #     d1[j]=d1.get(j,0)+1
        # for i in d1:
        #     if(i not in d or d[i]<d1[i]):
        #         return i
		
		#sol2
        if(len(s)==0):
            return t
        xor=ord(t[0])^ord(t[1])
        for i in s+t[2:]:
            xor=xor^ord(i)
        return chr(xor)
   
Qus 4: https://leetcode.com/problems/find-all-anagrams-in-a-string/submissions/
Sol:
class Solution(object):
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
        ls=len(s)
        lp=len(p)
        if(ls<lp or ls==0):
            return []
        sa=[0]*26
        pa=[0]*26
        idx_a=[]
        
        for i in p:
            pa[ord(i)-ord('a')]+=1
        
        for i in range(ls):
            if(i>=lp-1):
                
                sa[ord(s[i])-ord('a')]+=1
                #print sa,pa
                if(sa==pa):
                    idx_a.append(i-lp+1)
                sa[ord(s[i-lp+1])-ord('a')]-=1
                
                
            else:
                sa[ord(s[i])-ord('a')]+=1
        
        return idx_a


Qus 5 :https://leetcode.com/problems/bulls-and-cows/submissions/
Sol:
class Solution(object):
    def getHint(self, secret, guess):
        """
        :type secret: str
        :type guess: str
        :rtype: str
        """
        bull=0
        cow=0
        s={}
        g={}
        for i in range(len(guess)):
            if(secret[i]==guess[i]):
                bull+=1
            else:
                g[guess[i]]=g.get(guess[i],0)+1
                s[secret[i]]=s.get(secret[i],0)+1
        
        for i in g:
            cow+=min(s.get(i,0),g.get(i))
        return str(bull)+"A"+str(cow)+"B"
        
 Qus 6:https://leetcode.com/problems/island-perimeter/submissions/
Sol:
class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        n=len(grid)-1
        m=len(grid[0])-1
        parameter=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if(grid[i][j]==1):
                    if(i-1<0 or grid[i-1][j]==0):
                        parameter+=1
                    if(i+1>n or grid[i+1][j]==0):
                        parameter+=1
                    if(j-1<0 or grid[i][j-1]==0):
                        parameter+=1
                    if(j+1>m or grid[i][j+1]==0):
                        parameter+=1
        return parameter
                    
Qus 7:https://leetcode.com/problems/distribute-candies/submissions/
Sol:
 class Solution(object):
    def distributeCandies(self, candies):
        """
        :type candies: List[int]
        :rtype: int
        """
        n=len(candies)
        set1=set(candies)
        return min(n/2,len(set1))
		
Qus 8:https://leetcode.com/problems/design-hashset/submissions/
Sol:
class MyHashSet(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.set1=[False]*1000000

    def add(self, key):
        """
        :type key: int
        :rtype: None
        """
        self.set1[key]=True

    def remove(self, key):
        """
        :type key: int
        :rtype: None
        """
        self.set1[key]=False

    def contains(self, key):
        """
        Returns true if this set contains the specified element
        :type key: int
        :rtype: bool
        """
        return self.set1[key]


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)


Qus 9: https://leetcode.com/problems/find-common-characters/submissions/

Sol:
class Solution(object):
    def commonChars(self, A):
        """
        :type A: List[str]
        :rtype: List[str]
        """
        if(not len(A)):
            return []
        
        a=[0]*26
        
        for c in A[0]:
            a[ord(c)-ord('a')]+=1
        for i in A:
            b=[0]*26
            for c in i:
                b[ord(c)-ord('a')]+=1
            #a and b is created now we need to take min
            for i in range(26):
                a[i]=min(a[i],b[i])
        ans=[]
        for i,v in enumerate(a):
            for j in range(v):
                ans.append(chr(i+ord('a')))
        return ans
            
            
            
 Qus 10:
 Sol: